<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tmux Workspace</title>

    <!-- GoldenLayout 1.5.9 -->
    <link rel="stylesheet" href="https://golden-layout.com/files/latest/css/goldenlayout-base.css">
    <link rel="stylesheet" href="https://golden-layout.com/files/latest/css/goldenlayout-dark-theme.css">

    <!-- xterm.js 4.x (better CDN support) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@4.19.0/css/xterm.css">

    <!-- Custom styles -->
    <link rel="stylesheet" href="/static/css/style.css">
</head>
<body>
    <!-- Header -->
    <div id="header">
        <h1>Tmux Workspace</h1>
        <div id="controls">
            <button id="btn-new-bash">+ Bash</button>
            <button id="btn-new-tmux">+ Tmux</button>
            <button id="btn-save-layout">Save Layout</button>
        </div>
    </div>

    <!-- Tmux session selector modal -->
    <div id="tmux-modal" class="modal hidden">
        <div class="modal-content">
            <h3>Select Tmux Session</h3>
            <div id="session-list"></div>
            <button id="btn-close-modal">Cancel</button>
        </div>
    </div>

    <!-- GoldenLayout container -->
    <div id="layout-container"></div>

    <!-- Scripts -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://golden-layout.com/files/latest/js/goldenlayout.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm@4.19.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.5.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <script>
        // Socket.IO connection
        const socket = io();

        // Track terminals by component ID
        const terminals = new Map();
        let terminalIdCounter = Date.now(); // Use timestamp to avoid ID collisions across page reloads

        // Extract max termId from saved layout to avoid collisions
        function extractMaxTermId(config) {
            let maxId = 0;
            function traverse(item) {
                if (item.componentState && item.componentState.termId) {
                    const match = item.componentState.termId.match(/term-(\d+)/);
                    if (match) {
                        maxId = Math.max(maxId, parseInt(match[1], 10));
                    }
                }
                if (item.content) {
                    item.content.forEach(traverse);
                }
            }
            if (config && config.content) {
                config.content.forEach(traverse);
            }
            return maxId;
        }

        // GoldenLayout config
        const defaultConfig = {
            settings: {
                showPopoutIcon: false,
                showMaximiseIcon: true,
                showCloseIcon: true
            },
            content: [{
                type: 'row',
                content: [{
                    type: 'component',
                    componentName: 'welcome',
                    title: 'Welcome'
                }]
            }]
        };

        // Initialize GoldenLayout
        let layout;
        let savedLayout = null;

        // Load saved layout from server
        async function loadSavedLayout() {
            try {
                const res = await fetch('/api/layout');
                const data = await res.json();
                if (data && data.content) {
                    return data;
                }
            } catch (e) {
                console.error('Failed to load layout:', e);
            }
            return null;
        }

        // Save layout to server
        async function saveLayout() {
            if (!layout) return;
            try {
                const config = layout.toConfig();
                await fetch('/api/layout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                console.log('Layout saved');
            } catch (e) {
                console.error('Failed to save layout:', e);
            }
        }

        // Initialize app
        async function init() {
            savedLayout = await loadSavedLayout();
            const config = savedLayout || defaultConfig;

            // Set counter higher than any existing termId to avoid collisions
            const maxExisting = extractMaxTermId(config);
            if (maxExisting >= terminalIdCounter) {
                terminalIdCounter = maxExisting + 1;
            }

            layout = new GoldenLayout(config, $('#layout-container'));

            // Register welcome component
            layout.registerComponent('welcome', function(container) {
                container.getElement().html(`
                    <div class="welcome-panel">
                        <h2>Tmux Workspace</h2>
                        <p>Click <strong>+ Bash</strong> to open a new bash terminal.</p>
                        <p>Click <strong>+ Tmux</strong> to attach to a tmux session.</p>
                        <p>Drag tabs to rearrange or split the view.</p>
                    </div>
                `);
            });

            // Register terminal component
            layout.registerComponent('terminal', function(container, state) {
                console.log('Terminal component created:', state);
                // Always generate fresh termId on component creation to avoid stale server state
                const termId = `term-${++terminalIdCounter}`;
                const termType = state.type || 'bash';
                const session = state.session;
                const windowIdx = state.window || 0;

                const wrapper = $('<div class="terminal-wrapper"></div>');
                container.getElement().append(wrapper);

                // Create xterm instance
                const term = new Terminal({
                    cursorBlink: true,
                    fontSize: 14,
                    fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                    theme: {
                        background: '#1e1e1e',
                        foreground: '#cccccc',
                        cursor: '#ffffff'
                    }
                });

                const fitAddon = new FitAddon.FitAddon();
                term.loadAddon(fitAddon);

                // Store terminal info
                const termInfo = {
                    term,
                    fitAddon,
                    container,
                    type: termType,
                    session,
                    window: windowIdx,
                    connected: false
                };
                terminals.set(termId, termInfo);

                // Reconnect function
                function reconnect() {
                    if (termInfo.connected) return;
                    term.write('\r\n[Reconnecting...]\r\n');
                    connectTerminal(termId, termType, session, windowIdx);
                }

                // Open terminal when container is ready
                container.on('open', function() {
                    term.open(wrapper[0]);
                    fitAddon.fit();

                    // Track active panel on focus
                    const contentEl = container.getElement().closest('.lm_content');
                    term.textarea.addEventListener('focus', function() {
                        $('.lm_content').removeClass('panel-active');
                        contentEl.addClass('panel-active');
                    });

                    // Connect via Socket.IO
                    connectTerminal(termId, termType, session, windowIdx);
                });

                // Handle resize
                container.on('resize', function() {
                    fitAddon.fit();
                    if (terminals.get(termId)?.connected) {
                        socket.emit('terminal_resize', {
                            termId,
                            rows: term.rows,
                            cols: term.cols
                        });
                    }
                });

                // Handle close
                container.on('destroy', function() {
                    term.dispose();
                    terminals.delete(termId);
                    // Layout will auto-save on change
                });

                // Send input to server with paste throttling
                const CHUNK_SIZE = 1024;  // 1KB chunks
                const CHUNK_DELAY = 10;   // 10ms between chunks
                let pasteQueue = Promise.resolve();

                term.onData(function(data) {
                    if (!terminals.get(termId)?.connected) {
                        reconnect();
                        return;
                    }

                    // Small input (typing) - send immediately
                    if (data.length <= CHUNK_SIZE) {
                        socket.emit('terminal_input', { termId, data });
                        return;
                    }

                    // Large input (paste) - chunk it
                    pasteQueue = pasteQueue.then(() => {
                        return new Promise(resolve => {
                            let offset = 0;
                            function sendChunk() {
                                if (offset >= data.length) {
                                    resolve();
                                    return;
                                }
                                const chunk = data.slice(offset, offset + CHUNK_SIZE);
                                socket.emit('terminal_input', { termId, data: chunk });
                                offset += CHUNK_SIZE;
                                setTimeout(sendChunk, CHUNK_DELAY);
                            }
                            sendChunk();
                        });
                    });
                });

                // Store reconnect function for external use
                termInfo.reconnect = reconnect;

                // Update state for persistence (save type/session, not termId since we regenerate it)
                container.setState({
                    type: termType,
                    session,
                    window: windowIdx
                });
            });

            layout.init();

            // Auto-save layout on changes
            layout.on('stateChanged', function() {
                // Debounce saves
                clearTimeout(layout._saveTimeout);
                layout._saveTimeout = setTimeout(saveLayout, 500);
            });

            // Handle window resize
            $(window).resize(function() {
                layout.updateSize();
            });
        }

        // Connect terminal to server
        function connectTerminal(termId, type, session, window) {
            console.log('connectTerminal:', termId, type, session, window);
            const termInfo = terminals.get(termId);
            if (!termInfo) {
                console.log('Terminal not found:', termId);
                return;
            }

            console.log('Emitting open_terminal with termId:', termId);
            socket.emit('open_terminal', {
                termId,
                type,
                session,
                window
            });

            // Don't set connected yet - wait for terminal_ready
            termInfo.term.focus();
        }

        // Socket.IO event handlers
        socket.on('terminal_output', function(data) {
            const termId = data.termId;
            const output = data.data;
            const termInfo = terminals.get(termId);
            // Write output even before connected=true to avoid dropping early output
            if (termInfo) {
                termInfo.term.write(output);
            }
        });

        socket.on('terminal_ready', function(data) {
            const termId = data.termId;
            console.log('Terminal ready:', termId);
            const termInfo = terminals.get(termId);
            if (termInfo) {
                termInfo.connected = true;
                termInfo.fitAddon.fit();
                socket.emit('terminal_resize', {
                    termId,
                    rows: termInfo.term.rows,
                    cols: termInfo.term.cols
                });
            }
        });

        socket.on('terminal_closed', function(data) {
            const termId = data.termId;
            console.log('Terminal closed:', termId);
            const termInfo = terminals.get(termId);
            if (termInfo) {
                termInfo.connected = false;
                termInfo.term.write('\r\n[Terminal closed - press any key to reconnect]\r\n');
            }
        });

        socket.on('terminal_error', function(data) {
            const termId = data.termId;
            console.error('Terminal error:', termId, data.error);
            const termInfo = terminals.get(termId);
            if (termInfo) {
                termInfo.term.write(`\r\n[Error: ${data.error}]\r\n`);
            }
        });

        // Add new bash terminal
        function addBashTerminal() {
            const newItem = {
                type: 'component',
                componentName: 'terminal',
                title: 'Bash',
                componentState: {
                    type: 'bash',
                    termId: `term-${++terminalIdCounter}`
                }
            };

            // Add to layout
            if (layout.root.contentItems.length > 0) {
                layout.root.contentItems[0].addChild(newItem);
            } else {
                layout.root.addChild({
                    type: 'row',
                    content: [newItem]
                });
            }
        }

        // Show tmux session modal
        async function showTmuxModal() {
            console.log('showTmuxModal called');
            const modal = $('#tmux-modal');
            const list = $('#session-list');
            list.empty();

            try {
                console.log('Fetching sessions...');
                const res = await fetch('/api/sessions');
                const sessions = await res.json();
                console.log('Sessions:', sessions);

                if (sessions.length === 0) {
                    list.html('<p class="no-sessions">No tmux sessions found. Create one with: tmux new -s mysession</p>');
                } else {
                    sessions.forEach(session => {
                        const item = $(`
                            <div class="session-item" data-session="${session.name}">
                                <span class="session-name">${session.name}</span>
                                <span class="session-info">${session.windows} window(s) ${session.attached ? '(attached)' : ''}</span>
                            </div>
                        `);
                        item.on('click', function() {
                            addTmuxTerminal(session.name);
                            modal.addClass('hidden');
                        });
                        list.append(item);
                    });
                }
            } catch (e) {
                list.html('<p class="error">Failed to load sessions</p>');
            }

            modal.removeClass('hidden');
        }

        // Add tmux terminal
        function addTmuxTerminal(sessionName, windowIdx = 0) {
            console.log('addTmuxTerminal called:', sessionName, windowIdx);
            const newItem = {
                type: 'component',
                componentName: 'terminal',
                title: `tmux: ${sessionName}`,
                componentState: {
                    type: 'tmux',
                    session: sessionName,
                    window: windowIdx,
                    termId: `term-${++terminalIdCounter}`
                }
            };

            if (layout.root.contentItems.length > 0) {
                layout.root.contentItems[0].addChild(newItem);
            } else {
                layout.root.addChild({
                    type: 'row',
                    content: [newItem]
                });
            }
        }

        // Event listeners
        $(document).ready(function() {
            console.log('Document ready');
            console.log('Terminal available:', typeof Terminal);
            console.log('FitAddon available:', typeof FitAddon);
            console.log('GoldenLayout available:', typeof GoldenLayout);

            // Attach click handlers BEFORE init (in case init fails)
            $('#btn-new-bash').on('click', function() {
                console.log('Bash button clicked');
                addBashTerminal();
            });
            $('#btn-new-tmux').on('click', function() {
                console.log('Tmux button clicked');
                showTmuxModal();
            });
            $('#btn-close-modal').on('click', function() {
                $('#tmux-modal').addClass('hidden');
            });
            $('#btn-save-layout').on('click', saveLayout);

            // Close modal on outside click
            $('#tmux-modal').on('click', function(e) {
                if (e.target === this) {
                    $(this).addClass('hidden');
                }
            });

            // Initialize after handlers are set up
            try {
                init();
            } catch (e) {
                console.error('Init error:', e);
            }
        });
    </script>
</body>
</html>
